かしこまりました。
ご要求いただいた内容に基づき、C++/MFCでの実装を前提としたカスタムコントロールの仕様書を作成します。

---

## **ソフトウェア仕様書: 表形式カスタムコントロール**

### 1. 概要

本仕様書は、MFCアプリケーションのダイアログ上で使用する、表形式のカスタムコントロールについて定義するものです。
このコントロールは、特定セルの編集可否設定、マウスクリックやキーボード操作による直感的なデータ入力を可能にすることを目的とします。

### 2. 要求定義

#### 2.1. 機能要件
* 指定された行数・列数の表形式でデータを表示する。
* セルごとに編集可／不可を設定できる。
* マウス操作により、入力可能なセルを選択し、編集状態に移行できる。
* キーボードのカーソルキーで、入力可能なセル間を移動できる。
* 編集状態では、テキスト入力が可能で、Enterキーで確定、Escapeキーでキャンセルができる。

#### 2.2. 非機能要件
* ユーザーの操作に対し、視覚的なフィードバック（セルの色変化）を即座に行うこと。
* 直感的な操作性を提供し、ユーザビリティを高めること。

### 3. システムアーキテクチャ

* **実装方式:**
    * `CWnd`クラスを基底クラスとするカスタムコントロールとして実装します。これにより、描画、マウス、キーボードイベントを柔軟に処理できます。
    * このカスタムコントロールを、ダイアログリソースのカスタムコントロールとして配置、またはダイアログクラスのメンバ変数として動的に生成します。
* **アーキテクチャ:** ダイアログベースのアプリケーションでの利用を想定します。

### 4. 機能仕様

#### 4.1. 基本レイアウト
* **形式:** 6行2列のグリッド形式
* **枠線:** 各セルの境界に1ピクセルの実線を描画する。

#### 4.2. セルのプロパティ
各セルの初期状態におけるプロパティを以下のように定義します。

| セル (行, 列) | 初期背景色 | 編集可否 |
| :--- | :--- | :--- |
| (1, 1) | 灰色 | 不可 |
| (1, 2) | 灰色 | 不可 |
| (2, 1) | 灰色 | 不可 |
| (2, 2) | 白色 | **可能** |
| (3, 1) | 灰色 | 不可 |
| (3, 2) | 白色 | **可能** |
| (4, 1) | 灰色 | 不可 |
| (4, 2) | 白色 | **可能** |
| (5, 1) | 灰色 | 不可 |
| (5, 2) | 白色 | 不可 |
| (6, 1) | 灰色 | 不可 |
| (6, 2) | 白色 | **可能** |

#### 4.3. 状態と状態遷移
コントロール内のセルは、以下の3つの状態を持ちます。

1.  **通常状態 (Normal State):**
    * 初期状態。
    * 背景色: プロパティで定義された色（白色または灰色）。
2.  **選択状態 (Selected State):**
    * ユーザーが入力可能なセルを1回クリックした状態。
    * 背景色: **青色**
3.  **編集状態 (Edit State):**
    * 選択状態のセルを再度クリックした状態。
    * 背景色: **黄色**
    * テキスト入力のためのキャレットが表示される。

これらの状態遷移は、ユーザーの操作によって引き起こされます。詳細は以下の状態遷移図および説明を参照してください。

##### 状態遷移図 (テキスト表現)

```
                                +---------------------------+
                                |                           |
                                v                           |
[通常状態] --(入力可能セルを1回クリック)--> [選択状態] --(同じセルを1回クリック)--> [編集状態]
   ^                                           ^                                |
   |                                           |                                |
   +--(別の入力可能セルをクリック)-------------+                                +--(Enter/Escキー押下)--
   |
   +--(入力不可セルをクリック)--> [状態変化なし]

```

##### 状態遷移の詳細

* **通常状態 → 選択状態**
    * **トリガー:** ユーザーが「入力可能」なセルを1回クリックする。
    * **アクション:**
        1.  既に他のセルが「選択状態」であった場合、そのセルを「通常状態」（背景色: 白色）に戻す。
        2.  クリックされたセルを「選択状態」にし、背景色を青色に変更する。

* **選択状態 → 編集状態**
    * **トリガー:** ユーザーが「選択状態」のセルを再度クリックする。
    * **アクション:**
        1.  対象セルを「編集状態」にし、背景色を黄色に変更する。
        2.  セルの位置にインプレイスの`CEdit`コントロールを表示し、テキスト入力が可能な状態にする。キャレットを表示する。

* **編集状態 → 選択状態**
    * **トリガー:** 「編集状態」において、以下のいずれかの操作が行われる。
        1.  `Enter`キーが押される。
        2.  `Esc`キーが押される。
    * **アクション:**
        1.  **Enterキーの場合:** `CEdit`コントロールに入力されたテキストをセルに反映（確定）する。
        2.  **Escキーの場合:** `CEdit`コントロールに入力された内容を破棄（キャンセル）する。
        3.  `CEdit`コントロールを非表示・破棄する。
        4.  対象セルの状態を「選択状態」に戻し、背景色を青色に変更する。

* **入力不可セルのクリック**
    * **トリガー:** ユーザーが「編集不可」なセルをクリックする。
    * **アクション:**
        * クリックされたセル、および他のどのセルの状態も変化しない。
        * （例: あるセルが「選択状態」の時に、入力不可セルをクリックしても、元のセルの選択状態は維持される）

#### 4.4. キーボード操作
「選択状態」のセルがある場合に、カーソルキー（↑, ↓, ←, →）が押されると、フォーカスが移動します。

* **トリガー:** カーソルキーが押される。
* **アクション:**
    1.  現在「選択状態」にあるセルを基準とする。
    2.  押されたキーの方向に隣接するセルを探索する。
    3.  その方向に「入力可能」なセルが見つかった場合、最も近い「入力可能」なセルにフォーカスを移動する。
        * 移動元のセルは「通常状態」（背景色: 白色）に戻る。
        * 移動先のセルは「選択状態」（背景色: 青色）になる。（1回クリックされたのと同じ効果）
    4.  押されたキーの方向に「入力可能」なセルが存在しない場合は、何も変化しない。

### 5. クラス設計 (提案)

このカスタムコントロールを実装するために、以下のクラス設計を提案します。

* **クラス名:** `CGridCtrl` (仮)
* **基底クラス:** `CWnd`

#### 5.1. 主要なメンバ変数

```cpp
// セル一つ分の情報を保持する構造体
struct CellInfo {
    CString  m_strText;      // セルに表示するテキスト
    COLORREF m_bgColor;      // 背景色
    BOOL     m_bEditable;    // 編集可能フラグ
    // 必要に応じてフォント情報なども追加
};

class CGridCtrl : public CWnd
{
protected:
    // セル情報
    CellInfo m_cells[6][2];

    // 現在選択されているセルの位置 (-1, -1 で非選択)
    CPoint m_selectedCell;

    // インプレイス編集用のエディットコントロール
    CEdit* m_pEdit;

    // ...
};
```

#### 5.2. 主要なメンバ関数 (イベントハンドラ)

* `afx_msg void OnPaint()`
    * **役割:** コントロール全体の描画を担当する。
    * **処理:**
        * 6x2のグリッドと枠線を描画する。
        * `m_cells`配列の情報に基づき、各セルの背景色を塗りつぶす。
        * `m_cells`配列の情報に基づき、各セルのテキストを描画する。

* `afx_msg void OnLButtonDown(UINT nFlags, CPoint point)`
    * **役割:** マウスの左クリックイベントを処理する。
    * **処理:**
        * クリックされた座標(`point`)から、どのセルがクリックされたかを判定する。
        * クリックされたセルの`m_bEditable`フラグを確認する。
        * 状態遷移のロジック（本仕様書 4.3. 参照）に従い、セルの状態（`m_selectedCell`）と再描画(`Invalidate()`)を行う。
        * 必要に応じてインプレイス`CEdit`の生成・表示を行う。

* `afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)`
    * **役割:** キーボード入力を処理する。WM_GETDLGCODEをオーバーライドしてカーソルキーを受け取れるようにする。
    * **処理:**
        * `m_selectedCell`が有効な場合に処理を行う。
        * `nChar`がカーソルキーの場合、本仕様書 4.4. に従い、次に選択すべきセルを計算し、`m_selectedCell`を更新して再描画する。

* **ヘルパー関数**
    * `void CreateInPlaceEdit(CRect rect)`
        * **役割:** `CEdit`コントロールを動的に生成し、指定した矩形(`rect`)の位置に表示する。
    * `void DestroyInPlaceEdit(BOOL bUpdate)`
        * **役割:** 表示中の`CEdit`コントロールを破棄する。`bUpdate`がTRUEの場合、編集内容をセルに反映する。

### 6. 実装上の考慮事項

* **親ダイアログへの通知:** セルの内容が編集・確定された際、親ダイアログにその変更を通知する仕組みが必要です。`WM_COMMAND`やカスタムWindowsメッセージ (`WM_USER+n`) を `GetParent()->PostMessage()` で送信する方法が考えられます。
* **インプレイスCEdit:** `CEdit`コントロールからフォーカスが外れた場合 (`EN_KILLFOCUS`) や、`Enter`/`Esc`キーが押されたことを検知するために、`CEdit`をサブクラス化するか、親ウィンドウで`PreTranslateMessage`をオーバーライドしてメッセージをフックする必要があります。

---