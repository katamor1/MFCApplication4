
## ソフトウェア仕様書

本ドキュメントは、提供されたMFCアプリケーションソースコードに含まれる各クラスの設計と機能に関する仕様を定義します。

### 目次
1.  **CGridCtrl** (汎用グリッドコントロール)
2.  **CInPlaceEdit** (グリッド内編集コントロール)
3.  **CSoftwareKeyboardDlg** (ソフトウェアキーボード ダイアログ)
4.  **CKeyButton** (ソフトウェアキーボード キーボタン)
5.  **CMyEdit** (ソフトウェアキーボード起動エディット)
6.  **CCenterEdit** (多機能カスタムエディット)
7.  **CMyDialog** (スクロール可能ダイアログ 1)
8.  **CMyDialog2** (スクロール可能ダイアログ 2)
9.  **CMyDialog3** (機能ボタン連携ダイアログ)
10. **CView1** (カスタムビュー 1)
11. **CView2** (カスタムビュー 2)
12. **CMFCApplication4Dlg** (メインダイアログ)
13. **CMFCApplication4App** (アプリケーションクラス)

---

### 1. ソフトウェア仕様書: CGridCtrl

#### 1.1. 概要
`CWnd`を基底クラスとする、高機能な表形式（グリッド）のカスタムコントロールです。セルのプロパティ（編集可否、色、テキスト）を動的に設定でき、マウスやキーボードによる直感的な操作、および内部での垂直スクロール機能を持ちます。ちらつき防止のため、描画はダブルバッファリングで行われます。

#### 1.2. 機能要件
* **グリッド構成**:
    * 任意の行数・列数でグリッドを初期化できます (`SetupGrid`)。
    * 列ごとに幅 (`SetColumnWidth`)、全行の高さを一括で (`SetRowHeight`) 設定できます。
* **セルプロパティ**:
    * セルごとにテキスト (`SetCellText`)、編集可否 (`SetCellEditable`)、背景色 (`SetCellBgColor`) を設定できます。
    * 編集可能なセルは、内容に応じて背景色と文字色が動的に変化します。
        * 空欄: 薄黄色
        * 正の数値: オレンジ背景、青文字
        * 負の数値: 水色背景、赤文字
* **ユーザー操作**:
    * **マウスクリック**:
        * 編集可能なセルをクリックすると「選択状態」（青色背景）になります。
        * 選択状態のセルを再度クリックすると「編集状態」（黄色背景）になり、`CInPlaceEdit`コントロールによるインプレイス編集が開始されます。
    * **キーボードナビゲーション**:
        * 選択状態でカーソルキー（↑↓←→）を押すと、次に最も近い編集可能セルへフォーカスが移動します。
        * PageUp/PageDownキーで、表示されているページの分だけ編集可能セル間を移動します。
        * F2キーまたはEnterキーで、選択中のセルの編集を開始します。
* **スクロール**:
    * 総行数が表示可能行数 (`m_nMaxVisibleRows`) を超える場合、垂直スクロールバーが自動的に表示されます。
    * マウスホイール操作で垂直スクロールが可能です。
* **アクティブ状態**:
    * 複数のグリッドがウィンドウに配置された場合、現在操作対象のグリッドを「アクティブ状態」として区別できます (`SetActive`)。
    * アクティブ状態のグリッドは、外枠が太い青線で描画されます。

#### 1.3. クラス設計
* **クラス名**: `CGridCtrl`
* **基底クラス**: `CWnd`
* **主要なメンバ変数**:
    * `std::vector<CellInfo> m_cells`: 全セルの情報（テキスト、色、編集可否）を保持する動的配列。
    * `std::vector<int> m_colWidths`: 各列の幅を保持する動的配列。
    * `CPoint m_selectedCell`: 現在選択されているセルの位置を保持します。
    * `CInPlaceEdit* m_pEdit`: インプレイス編集用コントロールへのポインタ。
    * `int m_nTopRow`: スクロール時に、表示領域の先頭に来る行のインデックス。
    * `BOOL m_bIsActive`: このグリッドがアクティブ状態かを示すフラグ。
* **主要なメンバ関数**:
    * `OnPaint()`: ダブルバッファリングを用いてグリッド全体を描画します。
    * `OnLButtonDown()`: マウスクリックを処理し、セルの選択や編集状態への遷移を制御します。
    * `OnKeyDown()`: カーソルキー等によるナビゲーションを処理します。
    * `OnVScroll()`, `OnMouseWheel()`: 垂直スクロールを処理します。
    * `CreateInPlaceEdit()`, `DestroyInPlaceEdit()`: インプレイス編集コントロールの生成と破棄を管理します。
    * `SetActive()`: グリッドのアクティブ状態を設定・解除します。

#### 1.4. 親ウィンドウとの連携
以下のカスタムメッセージおよび通知コードを使用して親ウィンドウと連携します。
* `WM_GRID_CELL_CHANGED`: セルの内容が編集・確定されたことを通知します。
* `WM_GRID_ACTIVATED`: このグリッドがクリックされ、アクティブ状態になったことを通知します。
* `WM_GRID_NAV_BOUNDARY_HIT`: キーボード操作がグリッドの境界に達したことを通知し、親ウィンドウにフォーカス移動の判断を委ねます。
* `GCN_SELCHANGED` (WM_NOTIFY経由): マウスやキーボードで選択行が変更されたことを通知します。

---

### 2. ソフトウェア仕様書: CInPlaceEdit

#### 2.1. 概要
`CGridCtrl`のセル内でのテキスト編集（インプレイス編集）を実現するために使用される、`CEdit`から派生した専用のコントロールです。

#### 2.2. 機能要件
* `CGridCtrl`のセルが編集モードに入ると動的に生成されます。
* **編集の確定**: `Enter`キーが押されるか、フォーカスが他のコントロールに移ると、編集内容がセルに反映されます。
* **編集のキャンセル**: `Esc`キーが押されると、編集内容は破棄され、元のテキストに戻ります。
* 編集終了後、自身を自動的に破棄します。

#### 2.3. クラス設計
* **クラス名**: `CInPlaceEdit`
* **基底クラス**: `CEdit`
* **主要なメンバ変数**:
    * `CGridCtrl* m_pParentCtrl`: 親である`CGridCtrl`へのポインタ。
    * `CPoint m_cell`: 編集中のセルの位置。
    * `BOOL m_bEsc`: Escキーが押されたかどうかを記録するフラグ。
* **主要なメンバ関数**:
    * `PreTranslateMessage(MSG* pMsg)`: EnterキーとEscキーの押下を検知します。
    * `OnKillFocus(CWnd* pNewWnd)`: フォーカスを失った際のイベントを捕捉し、編集の終了処理（確定またはキャンセル）を親グリッドに依頼します。

---

### 3. ソフトウェア仕様書: CSoftwareKeyboardDlg

#### 3.1. 概要
マウス操作によるテキスト入力を提供するソフトウェアキーボード機能を持つ、モーダルダイアログです。 物理キーボードがない環境での使用を想定しています。

#### 3.2. 機能要件
* **表示と終了**:
    * 親ウィンドウの特定のエディットコントロールがフォーカスを受け取ると、モーダルで表示されます。
    * `Enter`キーでダイアログを閉じ、入力内容を確定します (`IDOK`)。
    * `Esc`キー、またはダイアログ右上の「×」ボタンでダイアログを閉じ、入力内容をキャンセルします (`IDCANCEL`)。
* **UIと操作**:
    * ダイアログ上部の青いタイトルバー領域をドラッグして、画面内でウィンドウを移動できます。
    * キーのレイアウト、ラベル、機能は静的配列 `g_KeyLayout` (`KeyDefine.h`内) によって定義され、ダイアログ初期化時に動的にキーボタンが生成されます。
* **キー入力**:
    * 通常の文字、数字、記号キーをクリックすると、対応する文字がターゲットのエディットコントロールに入力されます。
    * `Shift`, `Ctrl`, `Alt`, `CapsLock`, `Fn` キーはトグル式で、ONの状態ではキーの背景が青色に変わります。
    * `Shift`キーまたは`CapsLock`キーの状態に応じて、英字は大文字/小文字、記号は代替文字が入力されます。
    * `Backspace`, `Delete`, `Tab`, `Space` などのアクションキーも機能します。

#### 3.3. 画面仕様
* **レイアウト**: USキー配列をベースとした5行15列のキー構成で、`Tab`, `CapsLock`, `Shift`, `Enter`, `Space`などのキーは複数のキー幅を結合して表現されます。
* **サイズ**: キーのサイズ (34x34px) と隙間 (1px) から、ダイアログ全体のサイズが動的に計算されます。
* **デザイン**:
    * タイトルバー: 高さ34px、青色背景、右端に手動描画の「×」ボタン。
    * 通常キー: グレー背景、黒文字。Shiftキー押下時の代替文字は右下に灰色で表示。
    * ON状態の修飾キー: 青色背景、白文字。

#### 3.4. クラス設計
* **クラス名**: `CSoftwareKeyboardDlg`
* **基底クラス**: `CDialogEx`
* **主要なメンバ変数**:
    * `CEdit* m_pTargetEdit`: キー入力の送信先となるエディットコントロールへのポインタ。
    * `std::vector<CKeyButton*> m_KeyButtons`: 動的に生成された全キーボタンのポインタを保持します。
    * `m_bShiftOn`, `m_bCapsLockOn`, `m_bCtrlOn`, `m_bAltOn`, `m_bFnOn`: 各修飾キーのON/OFF状態を管理するフラグ。
    * `m_bDragging`, `m_ptMouseOffset`: ウィンドウのドラッグ移動に使われる変数。
* **主要なメンバ関数**:
    * `OnInitDialog()`: `g_KeyLayout` 配列を元に `CKeyButton` を動的に生成・配置し、ウィンドウサイズを調整します。
    * `OnPaint()`: カスタムタイトルバーと閉じるボタンの「×」を描画します。
    * `OnLButtonDown()`, `OnMouseMove()`, `OnLButtonUp()`: ウィンドウのドラッグ移動を実装します。
    * `OnKeyClick(UINT nID)`: 全てのキーボタンのクリックイベントを集約して処理します。
    * `HandleKeyPress(const KEY_INFO* pKeyInfo)`: キーの種類に応じて、文字送信や状態変更の処理を振り分けます。

---

### 4. ソフトウェア仕様書: CKeyButton

#### 4.1. 概要
`CSoftwareKeyboardDlg`上で個々のキーとして機能する、オーナードロー方式のカスタムボタンです。

#### 4.2. 機能要件
* 自身の見た目を、親ダイアログ (`CSoftwareKeyboardDlg`) の状態（例: ShiftキーがONか）と、自身に設定されたキー情報 (`KEY_INFO`) に基づいて動的に描画します。

#### 4.3. クラス設計
* **クラス名**: `CKeyButton`
* **基底クラス**: `CButton`
* **スタイル**: `BS_OWNERDRAW`
* **主要なメンバ変数**:
    * `const KEY_INFO* m_pKeyInfo`: 自身の属性（仮想キーコード、ラベル等）を保持する構造体へのポインタ。
    * `CSoftwareKeyboardDlg* m_pParentDlg`: 親ダイアログへのポインタ。
* **主要なメンバ関数**:
    * `DrawItem(LPDRAWITEMSTRUCT* lpDrawItemStruct)`: フレームワークからの描画要求に応じて、キーの背景、枠線、ラベル（通常時・Shift時）を描画する中心的な関数です。

---

### 5. ソフトウェア仕様書: CMyEdit

#### 5.1. 概要
`CEdit`を継承したカスタムコントロールで、フォーカスを受け取った際に`CSoftwareKeyboardDlg`を起動する機能を提供します。

#### 5.2. 機能要件
* コントロールがフォーカスを受け取ると（例: ユーザーによるクリック）、`CSoftwareKeyboardDlg`をモーダルダイアログとして表示します。
* ソフトウェアキーボードが「キャンセル」で閉じられた場合、コントロールのテキストをキーボード表示前の状態に復元します。
* ソフトウェアキーボードが閉じた後、フォーカスは親ウィンドウに戻ります。

#### 5.3. クラス設計
* **クラス名**: `CMyEdit`
* **基底クラス**: `CEdit`
* **主要なメンバ変数**:
    * `CString m_strOriginalText`: キーボード表示前のテキストをバックアップとして保持します。
* **主要なメンバ関数**:
    * `afx_msg void OnSetFocus(CWnd* pOldWnd)`: フォーカス取得時のイベントハンドラ。`CSoftwareKeyboardDlg`のインスタンス生成と`DoModal()`呼び出し、および結果に応じたテキスト復元処理を行います。

---

### 6. ソフトウェア仕様書: CCenterEdit

#### 6.1. 概要
テキストの垂直・水平中央揃え、フォーカスに応じた外観変更、ソフトウェアキーボードの起動といった複数の機能を持つ、高機能なカスタムエディットコントロールです。

#### 6.2. 機能要件
* **テキスト表示**:
    * テキストをコントロール内で垂直方向に中央、水平方向に右揃えで表示します。
    * コントロールのサイズが変更されても、中央揃えを維持します。
* **外観**:
    * フォーカスの有無に応じて、背景色と文字色が変化します。
        * **フォーカス時**: 黄色背景、赤色文字
        * **非フォーカス時**: シアン色背景、黒色文字
* **入力制御**:
    * 入力可能な最大文字数を4文字に制限します。
    * Enterキーを押しても改行されず、代わりに親ウィンドウにフォーカスが移ります。
* **ソフトウェアキーボード**:
    * フォーカスを受け取ると、`CMyEdit`と同様に`CSoftwareKeyboardDlg`を起動し、キャンセル時のテキスト復元機能も持ちます。

#### 6.3. クラス設計
* **クラス名**: `CCenterEdit`
* **基底クラス**: `CEdit`
* **主要なメンバ変数**:
    * `CBrush m_brushFocus`, `m_brushNoFocus`: フォーカス時/非フォーカス時の背景描画用ブラシ。
    * `COLORREF m_colorTextFocus`, `m_colorTextNoFocus`: フォーカス時/非フォーカス時の文字色。
    * `CString m_strOriginalText`: ソフトウェアキーボード用のテキストバックアップ。
* **主要なメンバ関数**:
    * `CtlColor(CDC* pDC, UINT nCtlColor)`: `WM_CTLCOLOR_REFLECT`メッセージを処理し、フォーカス状態に応じたブラシと文字色を設定します。
    * `UpdateTextPosition()`: テキストが垂直中央になるよう、内部の描画矩形を調整します。
    * `OnSize()`, `OnEnChange()`: コントロールのサイズ変更やテキスト変更のたびに`UpdateTextPosition()`を呼び出します。
    * `OnSetFocus(CWnd* pOldWnd)`: `CMyEdit`と同様にソフトウェアキーボードを起動します。
    * `PreSubclassWindow()`: コントロールの初期スタイル（右揃え、4文字制限など）を設定します。

---

### 7. ソフトウェア仕様書: CMyDialog

#### 7.1. 概要
`CGridCtrl`のインスタンスを複数（この実装では10個）縦に配置し、ダイアログ自体のスクロールバーで全体をナビゲーションするダイアログです。グリッド間のフォーカス移動もサポートします。

#### 7.2. 機能要件
* **レイアウト**:
    * `10行 x 1列`のグリッド配列に従い、10個の`CGridCtrl`インスタンスを動的に生成し、縦に配置します。
    * 各`CGridCtrl`は`表.txt`で定義された仕様（6行2列、特定のセルが編集可能）を持ちます。
* **スクロール**:
    * 全グリッドの合計高さがダイアログの高さを超える場合、垂直・水平スクロールバーが表示されます。
    * マウスホイール操作でも垂直・水平スクロールが可能です。
* **グリッド間ナビゲーション**:
    * あるグリッド内でカーソルキー操作が境界（上下左右の端）に達すると、隣接するグリッドにフォーカスが自動的に移動します。
    * 現在アクティブなグリッドは、そのグリッドの`SetActive(TRUE)`によって外枠が青く表示されます。
* **入力制御**:
    * EnterキーおよびEscキーによるダイアログの終了は無効化されています。

#### 7.3. クラス設計
* **クラス名**: `CMyDialog`
* **基底クラス**: `CDialogEx`
* **主要なメンバ変数**:
    * `CGridCtrl m_grids[TOTAL_GRIDS]`: グリッドコントロールの配列。
    * `CGridCtrl* m_pActiveGrid`: 現在アクティブなグリッドへのポインタ。
    * `m_nTotalWidth`, `m_nTotalHeight`: 全グリッドを配置した場合の合計サイズ。
    * `m_nHScrollPos`, `m_nVScrollPos`: 現在のスクロール位置。
* **主要なメンバ関数**:
    * `OnInitDialog()`: 全ての`CGridCtrl`を動的に生成・配置し、スクロールバーを初期化します。
    * `OnHScroll()`, `OnVScroll()`, `OnMouseWheel()`: スクロールイベントを処理します。
    * `OnSize()`: ダイアログのサイズ変更に応じてスクロールバーの状態を更新します。
    * `OnGridActivated(WPARAM, LPARAM)`: グリッドからのアクティブ化通知を受け取ります。
    * `OnGridNavBoundaryHit(WPARAM, LPARAM)`: グリッドの境界到達通知を受け取り、隣のグリッドへフォーカスを移します。
    * `ActivateGrid(CGridCtrl*)`: 指定されたグリッドをアクティブ化し、他のグリッドを非アクティブ化します。
    * `EnsureGridVisible(CGridCtrl*)`: 指定されたグリッドが画面内に表示されるように自動でスクロールします。

---

### 8. ソフトウェア仕様書: CMyDialog2

#### 8.1. 概要
`CMyDialog`と同様の基本構造を持ちますが、こちらは`5行 x 2列`のグリッド配列で合計10個の`CGridCtrl`を配置します。また、`CMyDialog`と異なり、**全てのセルは読み取り専用**です。

#### 8.2. 機能要件
* `CMyDialog`と同様のスクロール機能、グリッド間ナビゲーション機能、入力制御機能。
* **レイアウト**: `5行 x 2列`のグリッド配列に従い、10個の`CGridCtrl`インスタンスを動的に生成・配置します。
* **セルプロパティ**: 全てのグリッドの全てのセルが読み取り専用です。

#### 8.3. クラス設計
* `CMyDialog`とほぼ同じクラス構造を持ちますが、`GRID_ARRAY_ROWS`, `GRID_ARRAY_COLS`の定数値と、`OnInitDialog`でのセルプロパティ設定処理が異なります。

---

### 9. ソフトウェア仕様書: CMyDialog3

#### 9.1. 概要
`CGridCtrl`での行選択に連動して、機能ボタン群の表示内容と状態が動的に変化する対話的なダイアログです。

#### 9.2. 機能要件
* **初期状態**: `CGridCtrl`は非選択状態で、全ボタンは無効状態です。
* **行選択**:
    * `CGridCtrl`の行が選択されると、その行番号(`n`)を基に、8個の機能ボタンのラベルが「F(n-k)」形式で設定されます (ページ1)。
    * 行が選択されると、ページ番号は常に1にリセットされます。
* **次ページボタン**:
    * 選択された行の2列目が**空欄の場合にのみ**、次ページボタン「>>」が有効になります。
    * 次ページボタンを押すと、機能ボタンの表示がページ2の内容 (`F(n-9)`から`F(n-13)`) に切り替わります。ボタンはトグル式です。
* **機能実行**:
    * いずれかの機能ボタンが押されると、そのボタンが示す機能（`n`と`k`の値）を、カスタムメッセージ `WM_EXECUTE_FUNCTION` を使って親ウィンドウに通知します。
* **入力制御**:
    * EnterキーおよびEscキーによるダイアログの終了は無効化されています。

#### 9.3. 画面仕様
* **レイアウト**: 上部に`CGridCtrl`(16行2列)、その直下に水平に並んだ8個の機能ボタン (48x24px) と1個の次ページボタン (24x24px) が配置されます。

#### 9.4. クラス設計
* **クラス名**: `CMyDialog3`
* **基底クラス**: `CDialogEx`
* **主要なメンバ変数**:
    * `CGridCtrl m_gridCtrl`: グリッドコントロール。
    * `CButton m_btnFunc[8]`: 機能ボタンの配列。
    * `CButton m_btnNextPage`: 次ページボタン。
    * `int m_nSelectedRow`: 現在選択されている行のインデックス。
    * `int m_nCurrentPage`: 現在のページ番号 (1 or 2)。
* **主要なメンバ関数**:
    * `OnInitDialog()`: グリッドとボタンを動的に生成・配置します。
    * `OnGridSelChanged()`: グリッドの行選択通知を処理し、`UpdateButtons()`を呼び出します。
    * `OnNextPageClicked()`: 次ページボタンのクリックを処理し、ページ状態をトグルして`UpdateButtons()`を呼び出します。
    * `OnFuncButtonClicked(UINT nID)`: 機能ボタンのクリックを処理し、親ウィンドウにメッセージを送信します。
    * `UpdateButtons()`: 現在の状態 (`m_nSelectedRow`, `m_nCurrentPage`) に基づき、全てのボタンの表示と有効/無効状態を更新するヘルパー関数です。

---

### 10. ソフトウェア仕様書: CView1

#### 10.1. 概要
メインダイアログにプライマリビューとして配置されるカスタムビューです。ワーカースレッドを起動し、特定の条件成立時に親ウィンドウへ通知する役割を持ちます。

#### 10.2. 機能要件
* **ワーカースレッド**:
    * ビューのインスタンスが生成されると同時に、ワーカースレッド (`WorkerThreadProc`) を起動します。
    * スレッドは5秒間待機した後、親ウィンドウ (`CMFCApplication4Dlg`) に対して、`CView2`の表示を要求するカスタムメッセージ `WM_SHOW_VIEW2` を一度だけ送信します。
* **安全な終了**:
    * ビューのウィンドウが破棄される際 (`OnDestroy`)、ワーカースレッドに対して停止イベントを通知し、スレッドが安全に終了するのを待ちます。
* **描画**:
    * 背景は特定の色で塗りつぶされ、内部に2つの`CCenterEdit`コントロールを動的に配置します。
    * ウィンドウ作成時 (`PreCreateWindow`) にスタイルを調整し、上に他のビューが重なって表示されることを許容します。

#### 10.3. クラス設計
* **クラス名**: `CView1`
* **基底クラス**: `CView`
* **主要なメンバ変数**:
    * `CWinThread* m_pWorkerThread`: ワーカースレッドのインスタンスへのポインタ。
    * `CEvent m_eventStopThread`: ワーカースレッドに停止を通知するためのイベントオブジェクト。
* **主要なメンバ関数**:
    * `static UINT WorkerThreadProc(LPVOID pParam)`: ワーカースレッドのエントリポイントとなる静的関数。
    * `OnDestroy()`: ウィンドウ破棄時にスレッドの停止処理を行います。
    * `PreCreateWindow(CREATESTRUCT& cs)`: `WS_CLIPSIBLINGS`スタイルを削除し、`WS_EX_TRANSPARENT`スタイルを追加します。

---

### 11. ソフトウェア仕様書: CView2

#### 11.1. 概要
`CMFCApplication4Dlg`からの要求に応じて動的に生成され、`CView1`の上に重ねて表示されるカスタムビューです。

#### 11.2. 機能要件
* `WM_SHOW_VIEW2`メッセージをトリガーとして、`CView1`の右半分に重なるように表示されます。
* `CView1`と重なっている領域は描画されないように、ウィンドウリージョンによってクリッピングされます。
* 内部に2つの`CCenterEdit`コントロールを動的に配置します。
* ウィンドウ作成時 (`PreCreateWindow`) に`WS_CLIPSIBLINGS`スタイルを削除し、`CView1`との正常な重ね合わせを可能にします。

#### 11.3. クラス設計
* **クラス名**: `CView2`
* **基底クラス**: `CView`
* **主要なメンバ変数**:
    * `CCenterEdit *m_editCustom1`, `*m_editCustom2`: 内部に配置されるカスタムエディットコントロールへのポインタ。
* **主要なメンバ関数**:
    * `OnDraw(CDC* pDC)`: 初回描画時に`CCenterEdit`コントロールを生成・配置します。
    * `PreCreateWindow(CREATESTRUCT& cs)`: `WS_CLIPSIBLINGS`スタイルを削除します。

---

### 12. ソフトウェア仕様書: CMFCApplication4Dlg

#### 12.1. 概要
アプリケーションのメインウィンドウとなるダイアログです。本アプリケーションで定義された全てのカスタムコントロール、ビュー、ダイアログを管理し、それらの間の連携を制御します。

#### 12.2. 機能要件
* **コントロール管理**:
    * 起動時 (`OnInitDialog`) に、`CCenterEdit`, `CMyEdit`, `CView1` のインスタンスを動的に生成・配置します。
    * ダイアログ上のボタン（IDC\_BUTTON1, 2, 3）がクリックされると、それぞれ`CMyDialog`, `CMyDialog2`, `CMyDialog3`をモーダルで表示します。
* **メッセージ処理**:
    * `CView1`から`WM_SHOW_VIEW2`メッセージを受け取ると、`CView2`のインスタンスを生成し、`CView1`の上に重ねて表示します。
    * `CMyDialog3`から`WM_EXECUTE_FUNCTION`メッセージを受け取ると、実行された機能を示すメッセージボックスを表示します。
    * `CWinApp`から`WM_APP_SHOW_OPERATION_STATUS`メッセージを受け取ると、ウィンドウタイトルを3秒間「操作中」に変更するタイマーを起動します。
* **UI/UX制御**:
    * `Enter`キーと`Esc`キーによるダイアログの直接的な終了を無効化します (`PreTranslateMessage`, `OnOK`)。
    * タイトルバーの「×」ボタンやAlt+F4によるウィンドウクローズを無効化します (`OnSysCommand`)。
    * 明示的に配置された「OK」ボタン (`IDOK`) をクリックした場合のみ、ダイアログを終了します。

#### 12.3. クラス設計
* **クラス名**: `CMFCApplication4Dlg`
* **基底クラス**: `CDialogEx`
* **主要なメンバ変数**:
    * `m_editCustom1`, `m_editCustom2`, `m_pView1`, `m_pView2`, `m_editCustom3`: ダイアログが管理する各種コントロール/ビューへのポインタ。
    * `m_strOriginalTitle`: 「操作中」表示から元のタイトルに戻すためのバックアップ。
* **主要なメンバ関数**:
    * `OnInitDialog()`: UI要素の初期化と動的生成を行います。
    * `OnBnClickedButton1()`, `OnBnClickedButton2()`, `OnBnClickedButton3()`: 各ボタンに対応するモーダルダイアログを表示します。
    * `OnShowView2(WPARAM, LPARAM)`: `CView2`の表示ロジックを実装します。
    * `UpdateLayoutAndClipping()`: `CView1`と`CView2`が重なる部分の描画を制御します。
    * `OnExecuteFunction(WPARAM, LPARAM)`: `CMyDialog3`からの通知を処理します。
    * `OnShowOperationStatus(WPARAM, LPARAM)`: タイトル変更の処理を行います。
    * `OnTimer(UINT_PTR)`: タイトルを元に戻します。
    * `OnSysCommand(UINT, LPARAM)`: クローズコマンドを無効化します。

---

### 13. ソフトウェア仕様書: CMFCApplication4App

#### 13.1. 概要
アプリケーションのエントリポイントであり、アプリケーション全体のライフサイクルとグローバルなメッセージ処理を管理するクラスです。

#### 13.2. 機能要件
* **初期化**:
    * `InitInstance()`内で、`CMFCApplication4Dlg`をモーダルダイアログとして生成・表示します。ダイアログが閉じられると、アプリケーションは終了します。
* **グローバルメッセージフィルタリング**:
    * `PreTranslateMessage(MSG* pMsg)`をオーバーライドし、アプリケーション全体で特定のメッセージを横取りして処理します。
    * **無効化する操作**:
        * `Alt+F4` および `Alt+Space`
        * 全てのマウスダブルクリック
        * 全ての右クリック (`WM_RBUTTONDOWN`, `WM_CONTEXTMENU`)
        * タッチジェスチャ (`WM_GESTURE`)
    * **グローバルイベント**:
        * 任意のマウスクリックを検知すると、メインダイアログ (`m_pMainWnd`) に対して、カスタムメッセージ `WM_APP_SHOW_OPERATION_STATUS` を送信します。これにより、ユーザーが何か操作をするたびにメインダイアログのタイトルが一時的に「操作中」と表示されます。

#### 13.3. クラス設計
* **クラス名**: `CMFCApplication4App`
* **基底クラス**: `CWinApp`
* **主要なメンバ関数**:
    * `InitInstance()`: アプリケーションの初期化とメインダイアログの起動を行います。
    * `PreTranslateMessage(MSG* pMsg)`: アプリケーション全体のメッセージを横取りし、グローバルなUI制御を実装します。
    * `ExitInstance()`: アプリケーション終了時のクリーンアップ処理を行います。