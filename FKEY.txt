かしこまりました。ご要求いただいた内容に基づき、C++/MFCでの実装を前提としたダイアログ`MyDialog3`の仕様書を作成します。
既存の`表形式カスタムコントロール`の仕様を前提として、連携する機能の仕様を定義します。

-----

## **ソフトウェア仕様書: MyDialog3**

### 1\. 概要

本仕様書は、`MyDialog3`と名付けられたダイアログの設計と動作を定義するものです。このダイアログは、表形式カスタムコントロール(`CGridCtrl`)と複数の機能ボタン、ページ切り替えボタンで構成されます。

ユーザーが`CGridCtrl`内の特定の行を選択すると、その選択内容に応じて動的に機能が割り当てられたボタン群が表示されます。これにより、選択した項目に対してコンテキストに応じた操作を直感的に実行できるUIを提供することを目的とします。

### 2\. 要求定義

#### 2.1. 機能要件

  * 6行2列の表形式コントロール(`CGridCtrl`)を配置する。
      * 1列目は読み取り専用のキャプション、2列目は編集可能なデータ領域とする。
  * `CGridCtrl`の下に、8個の機能ボタンと1個の次ページボタンを配置する。
  * `CGridCtrl`でユーザーが行を選択すると、その選択行に関連付けられた機能がボタンに割り当てられる。
  * 機能ボタンが押されると、対応する機能IDを親ウィンドウに通知する。
  * `CGridCtrl`の選択行のデータが空欄の場合にのみ、次ページボタンが有効になり、追加の機能セット（ページ2）に切り替えられる。
  * 次ページボタンはトグル式で、再度押下すると元の機能セット（ページ1）に戻る。

#### 2.2. 非機能要件

  * ユーザーの操作（行選択、ボタン押下）に対し、ボタンの表示や有効/無効状態を即座に更新し、視覚的なフィードバックを返すこと。
  * 直感的な操作性を提供し、ユーザビリティを高めること。

### 3\. 画面仕様

#### 3.1. レイアウト

`MyDialog3`は、上部に`CGridCtrl`、その直下に機能ボタンと次ページボタンが水平に並んだレイアウトを持ちます。

```text
+-----------------------------------------------------+
|                                                     |
|                CGridCtrl (6行2列)                   |
|                  (IDC_GRID_CTRL)                    |
|                                                     |
|                                                     |
+-----------------------------------------------------+
| [ Func 1 ] [ Func 2 ] ... [ Func 8 ] [ >> ]          |
| <---- 48px ----> <1px>            <24px>            |
| (IDC_BTN_FUNC1 ... IDC_BTN_FUNC8) (IDC_BTN_NEXTPAGE)  |
+-----------------------------------------------------+
```

#### 3.2. コントロール定義

| コントロール名 | コントロールID (仮) | MFCクラス | サイズ | 備考 |
| :--- | :--- | :--- | :--- | :--- |
| グリッドコントロール | `IDC_GRID_CTRL` | `CGridCtrl` | - | [cite\_start]6行2列。詳細は`表形式カスタムコントロール`仕様書参照。 [cite: 1] |
| 機能ボタン1-8 | `IDC_BTN_FUNC1` - `IDC_BTN_FUNC8` | `CButton` | 48px × 24px | 機能実行用。ボタン間の間隔は1px。 |
| 次ページボタン | `IDC_BTN_NEXTPAGE` | `CButton` | 24px × 24px | 機能ページの切り替え用。機能ボタン8の右隣に配置。 |

### 4\. 機能仕様

#### 4.1. 初期状態

  * ダイアログ表示時、`CGridCtrl`のいずれの行も選択されていない状態です。
  * 全ての機能ボタンおよび次ページボタンは、非表示または無効状態となります。

#### 4.2. CGridCtrl 行選択時の動作

`CGridCtrl`の行がユーザーによって選択されると、以下の処理が実行されます。

1.  選択された行のインデックス（1始まりを `n` とする）を取得します。
2.  ページ状態を初期ページ（ページ1）にリセットします。
3.  選択された行 `n` の2列目のデータ（文字列）を取得します。
4.  取得したデータの内容に基づき、後述のロジックに従って機能ボタンと次ページボタンの表示を更新します。

#### 4.3. 次ページボタンの状態制御

次ページボタンの表示・状態は、`CGridCtrl`で選択された行の2列目のデータに依存します。

  * **データが空欄ではない場合:**
      * 次ページボタンのキャプションを空にします。
      * ボタンを**無効状態**にし、ユーザーが押せないようにします。
  * **データが空欄の場合:**
      * 次ページボタンのキャプションを「`>>`」と表示します。
      * ボタンを**有効状態**にし、ユーザーが押せるようにします。

#### 4.4. 機能ボタンの表示制御

機能ボタンに表示される内容は、`CGridCtrl`の選択行 `n` と、現在のページ番号に依存します。機能ラベルは `F(x)` の形式で表現することとします（`x`は機能インデックス）。

##### 4.4.1. ページ1 (初期状態)

  * **トリガー:**
      * `CGridCtrl`で新しい行が選択されたとき。
      * ページ2の状態で次ページボタンが押されたとき。
  * **表示内容:**
      * 8個の機能ボタンに、それぞれ `F(n-1)` から `F(n-8)` までのラベルを表示します。
      * 全ての機能ボタンは有効状態となります。
      * *(例: 3行目を選択した場合、ボタンには `F(2)` `F(1)` `F(0)` `F(-1)` `F(-2)` `F(-3)` `F(-4)` `F(-5)` が表示されます)*

##### 4.4.2. ページ2

  * **トリガー:**
      * 次ページボタンが有効な状態（選択行のデータが空欄）で、ユーザーがボタンを押したとき。
  * **表示内容:**
      * 先頭の5つの機能ボタンに、`F(n-9)` から `F(n-13)` までのラベルを表示し、有効状態とします。
      * 末尾の3つの機能ボタン（6, 7, 8番目）は、キャプションを空にし、無効状態とします。
      * *(例: 3行目を選択中に次ページへ遷移した場合、ボタンには `F(-6)` `F(-7)` `F(-8)` `F(-9)` `F(-10)` が表示され、残り3つは無効になります)*

#### 4.5. ボタン押下時のアクション

  * **機能ボタン:**
      * ユーザーがいずれかの機能ボタンを押すと、そのボタンに表示されている機能インデックス（例: `n-1`）を親ウィンドウに通知します。通知にはカスタムWindowsメッセージを使用します。
  * **次ページボタン:**
      * ユーザーが次ページボタンを押すと、ページ状態がトグル（ページ1 ⇔ ページ2）し、4.4.の仕様に従って機能ボタンの表示が更新されます。

### 5\. クラス設計 (提案)

#### 5.1. クラス名: `CMyDialog3`

  * **基底クラス:** `CDialogEx`

#### 5.2. 主要なメンバ変数

```cpp
public:
    // コントロール
    CGridCtrl m_gridCtrl;      // 表形式カスタムコントロール
    CButton   m_btnFunc[8];    // 8つの機能ボタン
    CButton   m_btnNextPage;   // 次ページボタン

protected:
    // 状態管理
    int m_nSelectedRow;      // 現在選択されている行インデックス (1始まり, -1で非選択)
    int m_nCurrentPage;      // 現在のページ番号 (1 or 2)
```

#### 5.3. 主要なメンバ関数

  * `virtual BOOL OnInitDialog()`

      * **役割:** ダイアログの初期化。
      * **処理:** `m_gridCtrl`や各ボタンコントロールを、ダイアログリソースのIDと関連付けます。`m_nSelectedRow`を-1に、`m_nCurrentPage`を1に初期化し、全ボタンを無効状態で開始します。

  * `afx_msg void OnGridSelChanged(NMHDR* pNMHDR, LRESULT* pResult)`

      * **役割:** `CGridCtrl`からの行選択変更通知（カスタムメッセージ）を処理します。
      * **処理:**
        1.  選択された行インデックス `n` を取得し、`m_nSelectedRow`に保存します。
        2.  `m_nCurrentPage` を `1` にリセットします。
        3.  ヘルパー関数 `UpdateButtons()` を呼び出します。

  * `afx_msg void OnNextPageClicked()`

      * **役割:** 次ページボタンのクリックイベントを処理します。
      * **処理:**
        1.  `m_nCurrentPage` の値をトグルします（1なら2へ、2なら1へ）。
        2.  ヘルパー関数 `UpdateButtons()` を呼び出します。

  * `afx_msg void OnFuncButtonClicked(UINT nID)`

      * **役割:** 8つの機能ボタンのクリックイベントを一括で処理します（`ON_COMMAND_RANGE`を使用）。
      * **処理:**
        1.  クリックされたボタンのID (`nID`) から、ボタンのインデックス（0-7）を特定します。
        2.  `m_nSelectedRow`、`m_nCurrentPage`、およびボタンインデックスから、通知すべき機能インデックスを計算します。
        3.  計算した機能インデックスをパラメータとして、`GetParent()->PostMessage()` で親ウィンドウにカスタムメッセージを送信します。

  * `void UpdateButtons()`

      * **役割:** `m_nSelectedRow`と`m_nCurrentPage`の状態に基づき、全ボタンの表示と有効/無効状態を更新する内部ヘルパー関数です。
      * **処理:**
        1.  `m_nSelectedRow`が-1（非選択）の場合、全ボタンを無効化して終了します。
        2.  `m_gridCtrl`から選択行の2列目のテキストを取得します。
        3.  テキストが空欄か否かで、次ページボタンのキャプション（`>>` or ""）と有効/無効状態を設定します（`EnableWindow()`）。
        4.  `m_nCurrentPage`の値に応じて、8つの機能ボタンのキャプションと有効/無効状態を設定します。

### 6\. 親ウィンドウとの連携

`CMyDialog3`と親ウィンドウ間の通知には、以下のカスタムWindowsメッセージを使用することを推奨します。

  * **`WM_GRID_SEL_CHANGED` (CGridCtrl -\> CMyDialog3)**

      * `CGridCtrl`内で新しい行が選択されたことを通知します。
      * `WPARAM`: 選択された行インデックス

  * **`WM_EXECUTE_FUNCTION` (CMyDialog3 -\> 親ウィンドウ)**

      * ユーザーが機能ボタンを押したことを通知します。
      * `WPARAM`: 実行すべき機能のインデックス

これらのメッセージIDは、`WM_USER`以上の値で定義する必要があります。

-----